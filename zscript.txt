version "3.2.0"

/* Copyright Alexander Kromm (mmaulwurff@gmail.com) 2018
 *
 * This file is part of Armament Tuning.
 *
 * Armament Tuning is free software: you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * Armament Tuning is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Armament Tuning.  If not, see
 * <https://www.gnu.org/licenses/>.
 */

// Some code is borrowed from gzdoom.pk3:
/*
**---------------------------------------------------------------------------
** Copyright 1999-2016 Randy Heit
** Copyright 2006-2017 Christoph Oelckers
** All rights reserved.
**
** Redistribution and use in source and binary forms, with or without
** modification, are permitted provided that the following conditions
** are met:
**
** 1. Redistributions of source code must retain the above copyright
**    notice, this list of conditions and the following disclaimer.
** 2. Redistributions in binary form must reproduce the above copyright
**    notice, this list of conditions and the following disclaimer in the
**    documentation and/or other materials provided with the distribution.
** 3. The name of the author may not be used to endorse or promote products
**    derived from this software without specific prior written permission.
**
** THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
** IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
** OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
** IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
** INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
** NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
** THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
**---------------------------------------------------------------------------
**
*/

class m8f_at_EventHandler : EventHandler
{
  void MaybeDisableWeaponCrushing(Actor a)
  {
    bool disableCrushing = CVar.FindCVar("m8f_wm_DisableWeaponCrushing").GetInt();
    if (disableCrushing) { a.bDONTGIB = true; }
  }

  void MaybeDisableAmmoCrushing(Actor a)
  {
    bool disableCrushing = CVar.FindCVar("m8f_wm_DisableAmmoCrushing").GetInt();
    if (disableCrushing) { a.bDONTGIB = true; }
  }

  void MaybeDisableGibbing(Actor a)
  {
    bool disableGibbing = CVar.FindCVar("m8f_wm_DisableGibbing").GetInt();
    if (disableGibbing) { a.bNOEXTREMEDEATH = true; }
  }

  override void WorldThingSpawned(WorldEvent e)
  {
    if (e == null) { return; }

    Actor thing = e.thing;
    if (thing == null) { return; }

    MaybeDisableGibbing(thing);

    Weapon w = Weapon(thing);
    if (w != null)
    {
      CVar  kickbackMultiplierCVar = CVar.FindCVar("m8f_wm_KickbackMultiplier");
      float kickbackMultiplier     = kickbackMultiplierCVar.GetFloat();
      w.Kickback *= kickBackMultiplier;

      CVar  bobMultiplierCVar = CVar.FindCVar("m8f_wm_BobMultiplier");
      float bobMultiplier     = bobMultiplierCVar.GetFloat();
      w.BobRangeX *= bobMultiplier;
      w.BobRangeY *= bobMultiplier;

      MaybeDisableWeaponCrushing(thing);
    }

    if (thing.bMISSILE)
      {
        float missileSizeMultiplier = CVar.FindCVar("m8f_wm_MissileSizeMultiplier").GetFloat();
        thing.scale *= missileSizeMultiplier;
      }

    Inventory i = Inventory(thing);
    if (i == null) { return; }
    if (i.owner) { return; }

    Ammo a = Ammo(thing);
    if (a != null)
    {
      CVar  ammoMultiplierCVar = CVar.FindCVar("m8f_wm_AmmoMultiplier");
      float ammoMultiplier     = ammoMultiplierCVar.GetFloat();
      if (a.Amount != 0) // why there would be ammo not giving ammo? I don't know.
      {
        a.Amount *= ammoMultiplier;
        if (a.Amount == 0) { a.Amount = 1; }
      }

      MaybeDisableAmmoCrushing(thing);
    }
    else
    {
      Weapon w = Weapon(thing);
      if (w != null)
      {
        CVar  ammoMultiplierCVar = CVar.FindCVar("m8f_wm_AmmoMultiplier");
        float ammoMultiplier     = ammoMultiplierCVar.GetFloat();

        if (w.AmmoGive1 != 0)
        {
          w.AmmoGive1 *= ammoMultiplier;
          if (w.AmmoGive1 == 0 ) { w.AmmoGive1 = 1; }
        }

        if (w.AmmoGive2 != 0)
        {
          w.AmmoGive2 *= ammoMultiplier;
          if (w.AmmoGive2 == 0 ) { w.AmmoGive2 = 1; }
        }

        // spawn light
        CVar lightUpCVar = CVar.FindCVar("m8f_wm_LightNotAcquiredWeapons");
        bool lightUp     = lightUpCVar.GetInt();
        if (lightUp)
        {
          vector3 p = w.SpawnPoint;
          WM_Lighter light = WM_Lighter(Actor.Spawn("WM_Lighter", p));
          light.checkedWeapon = w.GetClassName();
        }
      }
    }
  }

  Override Void NetworkProcess(ConsoleEvent e)
  {
    if(e.name == 'm8f_at_givethisammo')
    {
      PlayerInfo player = players[consolePlayer];
      Weapon w = player.ReadyWeapon;
      if (!w) { return; }

      Ammo amm1 = w.Ammo1;
      Ammo amm2 = w.Ammo2;
      if (amm1) { player.mo.GiveInventory(amm1.GetClassName(), 10); }
      if (amm2) { player.mo.GiveInventory(amm2.GetClassName(), 10); }
    }
  }
}

class WM_Lighter : Actor
{
  string checkedWeapon;

  Default
  {
    +NOGRAVITY;
  }

  States
  {
  Spawn:
    TNT1 A 0;
    TNT1 A 0 a_jumpifinventory(checkedWeapon, 1, "NoLight", AAPTR_PLAYER1);
  Light:
    TNT1 A 10;// A_Log("light");
    goto Spawn;
  NoLight:
    TNT1 B 35;// A_Log("no light");
    loop;
  }
}
